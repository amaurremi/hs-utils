 You can make `CmdFunctions.hs' more modular and remove
 duplicated code with the following functions:

   --  For a particular path, opens an appropriate read handle.
   --  and pairs it with the path. As a special case, "-" is
   --  paired with STDIN.
   readHandleWithPath      ::  String -> IO (String, Handle)

   --  Read ARGV and determine what read handles should be
   --  available. As a special case, when ARGV is empty we
   --  should have just [("-", stdin)].
   getReadHandles          ::  IO [(String, Handle)]

   --  Execute an action against the read handles, capturing
   --  the results it generates.
   execute                 ::  ((String, Handle) -> IO a) -> IO [a]

   --  Execute an action against the read handles, discarding
   --  their results.
   execute_                ::  ((String, Handle) -> IO a) -> IO ()

 Try implementing it this way. See how much code you can share
 between `execute' and `execute_'; you may need an auxilliary
 function. In Haskell, function calls are fast so we can pay a
 little (or nothing) to avoid repeating ourselves.

 The `runner', `runner_' idiom, where the one with the
 underscore throws out the results of an action, is common for
 monadic operations that work with lists. For example:

   sequence        sequence_
   mapM            mapM_

 Now in `cat.hs' you have to modify the core action to work
 with a tuple, discarding the first element; while in `wc.hs'
 you have to map over the results with a display function.

 It is worth noting that I interchanged the meaning and use of
 your `execute' and `execute1'; we use `execute_' in `cat.hs'
 and `execute' in `wc.hs'. Why did I do that? Well, it is to
 make things more like `sequence', `sequence_' and other
 monadic actions. Thus I removed the `run' parameter to
 `execute1' (now `execute') and suggest using a monadic map
 (this will make my `execute' more re-usable than your
 `execute1' in practice).

 I think introducing a `Result' type would be good if we had a
 well established notion of some consistent result that would
 be shared across commands; but in `execute' and `execute_' the
 type signatures are completely agnostic about this and allow
 each utility to do what it likes. An important part of
 modularity is safe-guarding the freedom of users of our code.
